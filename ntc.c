#include "stm32f0xx.h"
#include "ntc.h"

/* Таблица суммарного значения АЦП в зависимости от температуры. От большего значения к меньшему
   Для построения таблицы использованы следующие парамертры:
     R1(T1): 10кОм(25°С)
     Таблица R/T характеристик: EPCOS R/T:4901; B25/100:3950K
     Схема включения: C
     Ra: 10кОм
     Напряжения U0/Uref: 3.3В/3.3В
*/
const uint16_t termo_table[] = {
    4028, 4027, 4027, 4026, 4025, 4024, 4023, 4023,
    4022, 4021, 4020, 4019, 4018, 4017, 4016, 4015,
    4015, 4014, 4013, 4012, 4011, 4010, 4009, 4008,
    4007, 4005, 4004, 4003, 4002, 4001, 4000, 3999,
    3998, 3996, 3995, 3994, 3993, 3991, 3990, 3989,
    3988, 3986, 3985, 3984, 3982, 3981, 3979, 3978,
    3976, 3975, 3973, 3972, 3970, 3969, 3967, 3966,
    3964, 3962, 3961, 3959, 3957, 3956, 3954, 3952,
    3950, 3948, 3946, 3944, 3943, 3941, 3939, 3937,
    3935, 3932, 3930, 3928, 3926, 3924, 3921, 3919,
    3917, 3915, 3912, 3910, 3907, 3905, 3902, 3900,
    3897, 3894, 3892, 3889, 3886, 3883, 3881, 3878,
    3875, 3872, 3869, 3866, 3863, 3860, 3856, 3853,
    3850, 3847, 3843, 3840, 3836, 3833, 3829, 3825,
    3822, 3818, 3814, 3810, 3806, 3802, 3798, 3794,
    3789, 3785, 3781, 3776, 3772, 3767, 3763, 3758,
    3753, 3748, 3743, 3738, 3733, 3728, 3723, 3718,
    3712, 3707, 3701, 3696, 3690, 3684, 3678, 3672,
    3666, 3660, 3654, 3648, 3641, 3635, 3628, 3621,
    3614, 3608, 3601, 3593, 3586, 3579, 3571, 3564,
    3556, 3548, 3540, 3532, 3524, 3516, 3508, 3499,
    3491, 3482, 3473, 3464, 3455, 3446, 3436, 3427,
    3417, 3407, 3397, 3387, 3377, 3367, 3356, 3346,
    3335, 3324, 3313, 3302, 3291, 3279, 3267, 3256,
    3244, 3231, 3219, 3206, 3194, 3181, 3168, 3155,
    3141, 3128, 3114, 3100, 3086, 3072, 3058, 3043,
    3028, 3013, 2998, 2983, 2968, 2953, 2937, 2921,
    2905, 2889, 2873, 2856, 2840, 2823, 2806, 2789,
    2772, 2754, 2737, 2719, 2701, 2683, 2665, 2646,
    2627, 2609, 2590, 2570, 2551, 2532, 2512, 2492,
    2472, 2452, 2432, 2412, 2391, 2370, 2350, 2329,
    2308, 2287, 2265, 2244, 2223, 2201, 2180, 2158,
    2136, 2114, 2092, 2070, 2048, 2026, 2003, 1981,
    1958, 1936, 1913, 1891, 1868, 1845, 1823, 1800,
    1778, 1755, 1733, 1711, 1688, 1666, 1644, 1621,
    1599, 1577, 1555, 1532, 1510, 1488, 1467, 1445,
    1423, 1401, 1380, 1358, 1337, 1315, 1294, 1273,
    1252, 1232, 1211, 1190, 1170, 1150, 1130, 1110,
    1090, 1070, 1051, 1032, 1013, 994, 975, 956,
    937, 919, 901, 883, 865, 847, 830, 812,
    795, 778, 762, 745, 729, 713, 698, 682,
    667, 652, 637, 623, 609, 595, 582, 568,
    555, 542, 529, 517, 505, 493, 481, 469,
    458, 446, 435, 425, 414, 404, 393, 383,
    374, 364, 355, 345, 336, 328, 319, 310,
    302, 294, 286, 278, 271, 263, 256, 249,
    242, 235, 229, 222, 216, 210, 204, 198,
    192, 187, 181, 176, 171, 166, 161, 156,
    151, 147, 142, 138, 134, 130, 126, 122,
    118, 114, 111, 107, 104, 101, 97, 94,
    91, 88, 85, 83, 80, 77, 75, 72,
    70, 68, 65, 63, 61, 59, 57, 55,
    53, 51, 49, 48, 46
};

// Функция вычисляет значение температуры в десятых долях градусов Цельсия
// в зависимости от суммарного значения АЦП.
int16_t calc_temperature(uint16_t adcsum) {
  uint16_t l = 0;
  uint16_t r = (sizeof(termo_table) / sizeof(termo_table[0])) - 1;
  uint16_t thigh = TEMPERATURE_TABLE_READ(r);
  
  // Проверка выхода за пределы и граничных значений
  if (adcsum <= thigh) {
    #ifdef TEMPERATURE_UNDER
      if (adcsum < thigh) 
        return TEMPERATURE_UNDER;
    #endif
    return TEMPERATURE_TABLE_STEP * r + TEMPERATURE_TABLE_START;
  }
  uint16_t tlow = TEMPERATURE_TABLE_READ(0);
  if (adcsum >= tlow) {
    #ifdef TEMPERATURE_OVER
      if (adcsum > tlow)
        return TEMPERATURE_OVER;
    #endif
    return TEMPERATURE_TABLE_START;
  }

  // Двоичный поиск по таблице
  while ((r - l) > 1) {
    uint16_t m = (l + r) >> 1;
    uint16_t mid = TEMPERATURE_TABLE_READ(m);
    if (adcsum > mid) {
      r = m;
    } else {
      l = m;
    }
  }
  uint16_t vl = TEMPERATURE_TABLE_READ(l);
  if (adcsum >= vl) {
    return l * TEMPERATURE_TABLE_STEP + TEMPERATURE_TABLE_START;
  }
  uint16_t vr = TEMPERATURE_TABLE_READ(r);
  uint16_t vd = vl - vr;
  int16_t res = TEMPERATURE_TABLE_START + r * TEMPERATURE_TABLE_STEP; 
  if (vd) {
    // Линейная интерполяция
    res -= ((TEMPERATURE_TABLE_STEP * (int32_t)(adcsum - vr) + (vd >> 1)) / vd);
  }
  return res;
}